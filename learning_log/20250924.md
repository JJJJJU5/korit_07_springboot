# 금일
백엔드-프론트엔드 연결 예정

# RESTful API 문서화
- RESTful API는 이를 이용하는 개발자가 그 기능과 작동을 이해할 수 있도록 적절하게 문서화 되어야 한다.
- 내가 개발하는데 왜 문서가 필요하냐고 하면 안된다.
- 이번에는 Open API 3를 이용하여 이용할 수 있는 엔드포인트 목록 / 허용되는 데이터 양식 / API와 상호작용 하는 방법 등을 포함시킬 예정이다.

OpenAPI3를 이용한 자동 문서 생성 방식(이전에는 Swagger 명세라고 했다.)인데, 이는 RESTful API를 위한 API 설명 명세서에 해당한다. RAML도 있기는한데 한국에서 잘 사용하지 않는 편이다.

OPENAPI도 라이브러리이다.
1. 
```gradle
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'
```
이를 통해 알게 되는 점은 '외부 라이브러리' 를 사용한다면 Java 자체를 이용하는 것이 아니기 떄문에 _의존성 추가_ 가 선행돼야 한다는 점이다. 그럼 의존성 추가는 어디서 하는지 -> build.gradle에서 한다. 여기 dependencies에 의존성 삽입 -> 끝으로 코끼리를 새고고침 해야 한다.

2. com.example.cradatabase 패키지에 OpenApiConfig 클래스를 생성 

```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
   
    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                ); 
    }
}
```
이상의 코드에서 학습해야 할 부분은 `@Bean`이라는 애너테이션이다. 그리고 return new OpenAPI.info(...); 라는 지점에서 chaining method 개념을 도입했고, 거기 new info() 내에 객체 생성을 빌더 패턴으로 했다는 점에 주목하면 된다. 그러면 `@Bean` 빼고는 전부 다 학습한 내용이다.

3. application.properties도 수정
```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver=class-name=org.mariadb.jdbc.Driver
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.data.rest.basePath=/api
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api.docs
```

이후
http://localhost:8080/swagger-ui.html

# Bean / @Bean
- Spring에서 Bean은  스프링 IoC(Inversion of Control : 제어의 역전) 컨테이너가 관리하는 Java 객체를 의미한다.

## Bean의 정의
Spring이 등장하기 전에는 개발자가 직접 new 키워드를 통한 객체 생성을 하고, 객체 간의 의존성을 관리했다.(우리가 Java 시간에 해왔던 것). 얘가 편하게 느껴지지만 프로젝트가 커질 수록 코드가 복잡해지고 유지 보수가 어려워지는 단점이 있다.
예를 들어 A 클래스를 정의하고 B 클래스에서 A 클래스의 객체를 만들었을 때, A 클래스의 내부를 수정했더니 B에서 코드 오류가 나는 경우가 빈번했다.

Spring에서는 이상의 문제를 IoC 개념을 통해서 해결했다. 개발자가 직접 특정 클래스에서 객체를 생선하는 것이 아니라 Spring IoC 컨테이너에게 객체 생성 자체를 위임한다.
스프링 컨테이너는 애플리케이션에서 필요한 객체들을 미리 생성해두고(Bean), 필요할 떄 특정 클래스에게 주입을 해준다.
이렇게 스프링 컨테이너에 의해 관리되는 객체를 _빈_ 이라고 한다.

그리고 이 bean은 싱글톤 스코프로 관리된다. 그러면 전체를 통틀어서 하나의 객체만 생성되는 것을 담보하기 때문에 메모리 효율성을 높이고 일관된 상태를 유지할 수 있다.

## @Bean 애너테이션
`@Bean` 애너테이션은 메서드에 붙여서 사용하며, 이 메서드가 반환하는 객체를 스프링 컨테이너에 빈으로 등록하겠다는 의미이다. 

### @Bean 애너테이션 사용 방법
`@Bean`은 주로 `@Configuration`이 붙은 클래스 내부의 메서드에서 사용된다. `@Confiuration`은 해당 클래스가 빈 설정 정보를 가지고 있음을 나타낸다.

- 우리가 OpenAPI를 도입했을 때의 애너테이션을 확인하면 된다.
```java
package com.example.cardatabase;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI carDatabaseOpenApi() {
        return new OpenAPI()
                .info(new Info()
                        .title("Car REST API")
                        .description("My car Stock")
                        .version("1.0")
                );
    }
}
```

### @Bean의 사용 여부에 따른 코드 라인의 차이
1. @Bean을 사용하지 않았을 때의 예시
  - @Bean을 사용하지 않으면 개발자가 직접 객체를 생성하고 관리한다.

```java
public class MyService {
  public void doSomething() {
    System.out.println("이 method가 무슨 일을 하고 있습니다.");
  }
public class MyController {
  // 개발자가 직접 메서드를 호출하기 위해서 객체를 생성했다.
private MyService myService1 = new MyService();

  public void handleRequest() {
  myService1.doSomething(); // MyController 클래스에서 MyService 객체를 만든 다음에 메서드를 호출했다.
  }  
}
}
```
그러면 현재까지의 상황을 봤을 때 전혀 이상한게 없다. 여태까지 그렇게 해왔으니까

이상의 방식은 의존성 주입(Dependency Inhection)을 활용하지 않아. 객체 간의 결합도가 높아지고 테스트 및 유지 보수가 어렵다는 단점이 있다. 즉 MyController 클래스만 테스틀 해보고 싶어도 내부에서 MyService 객체를 만들어 버리니까 MyService 클래스까지 무조건 같이 테스트를 해야한다는 부분이 문제이다. 만약에 특정 클래스에서 다른 클래스의객체를 300개 만들면 301개의 클래스를 테스트 해야한다.


@ Bean을 사용했을 때의 예시
- @Bean을 사용하면 스프링 컨테이너가 MyService 클래스의 객체를 생성하고 관리한다. 그리고 `@Autowired`를 통해서 이 객체를 주입 받아 사용한다.

```java
@Configuration
public class AppConfig{
  // MyService 객체를 빈으로 등록하는 과정
  @Bean
  public MyService myService() {
    return new myService()
  }
}

public class myService {
  public void doSomething() {
    System.out.println("실행합니다.")
  }
}

@Controller
public class MyController {
  private final MyService myService; // 아까 위와의 차이점은 우리가 이 클래스에서 객체를 생성하지 않고서 field로 처리한다는 점이다.

  // 생성자 주입
  public MyController(MyService MyService) {
    this.myService = myService
  }
  public void handleReques() {
    myService.doSomething();
  }
}
```
이상의 예시에서 @Configuration 이 붙어있는 appConfig 클래스는 스프링 빈 구성 클래스로 동작하게 된다. myService() 메서드에 @Bean 애너테이션을 붙여서, 결과값이 MyService의 객체가 되고, 이를 스프링 컨테이너에 등록하게 된다. 이상의 작업이 선행되게 되면 MyController 클래스에서는 new 키워드 없이, 생성자를 통해 바로 스프링 컨테이너로부터 MyService 객체를 전달 받아서 사용할 수 있다. 그러면 객체가 통째로 하나만 있다는 것을 담보 할 수 있기 때문에 new를 쓸 때 처럼 객체 개수가 계속 늘어나지도 않고, 메모리 효율성과 일관성을 가질 수 있으면서도 MyController - MyService 클래스 간의 결합도도 낮추는 효과를 지닌다.

# 백엔드 보호로 넘어가기 전에 push
git add .
git commit -m "feat : RESTful API + Swagger"
git push